package com.example.ble.ble

import android.Manifest
import android.annotation.SuppressLint
import android.bluetooth.*
import android.bluetooth.le.*
import android.content.Context
import android.content.pm.PackageManager
import android.os.Build
import android.util.Log
import androidx.core.content.ContextCompat
import com.example.ble.models.BleDevice
import com.example.ble.models.MediaMetadata
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import java.util.*

private const val TAG = "BleManager"

@SuppressLint("MissingPermission")
class BleManager(private val context: Context) {

    // BLE Components
    private val bluetoothManager = context.getSystemService(Context.BLUETOOTH_SERVICE) as BluetoothManager
    private val bluetoothAdapter = bluetoothManager.adapter
    private val scanner = bluetoothAdapter.bluetoothLeScanner
    
    // GATT Server and Client
    private var gattServer: BluetoothGattServer? = null
    private var gattClient: BluetoothGatt? = null
    
    // Connected devices
    private val connectedDevices = mutableSetOf<BluetoothDevice>()
    private val subscribedDevices = mutableSetOf<BluetoothDevice>()
    
    // Track characteristic subscriptions per device
    private val deviceSubscriptions = mutableMapOf<BluetoothDevice, MutableSet<UUID>>()
    
    // Track change detection
    private var currentMediaMetadata: MediaMetadata? = null
    private var trackChangeCounter = 0
    
    // Service UUIDs - Media Control Service (MCS) Bluetooth SIG Standard
    companion object {
        // MCS Service UUID (0x1849)
        val MEDIA_SERVICE_UUID = UUID.fromString("00001849-0000-1000-8000-00805f9b34fb")
        
        // MCS Characteristics - Official Bluetooth SIG UUIDs
        val MP_NAME_UUID = UUID.fromString("00002b93-0000-1000-8000-00805f9b34fb")          // Media Player Name (Source ID)
        val TRACK_CHANGED_UUID = UUID.fromString("00002b96-0000-1000-8000-00805f9b34fb")    // Track Changed
        val TITLE_UUID = UUID.fromString("00002b97-0000-1000-8000-00805f9b34fb")            // Track Title
        val DURATION_UUID = UUID.fromString("00002b98-0000-1000-8000-00805f9b34fb")         // Track Duration
        val POSITION_UUID = UUID.fromString("00002b99-0000-1000-8000-00805f9b34fb")         // Track Position
        val STATE_UUID = UUID.fromString("00002ba3-0000-1000-8000-00805f9b34fb")            // Media State
        val MCP_UUID = UUID.fromString("00002ba4-0000-1000-8000-00805f9b34fb")              // Media Control Point
        val MCP_OPCODE_SUPPORTED_UUID = UUID.fromString("00002ba5-0000-1000-8000-00805f9b34fb") // MCP Opcodes Supported
    }

    // State flows for UI
    private val _scannedDevices = MutableStateFlow<List<BleDevice>>(emptyList())
    val scannedDevices: StateFlow<List<BleDevice>> = _scannedDevices.asStateFlow()
    
    private val _isScanning = MutableStateFlow(false)
    val isScanning: StateFlow<Boolean> = _isScanning.asStateFlow()
    
    private val _connectionState = MutableStateFlow<String>("Disconnected")
    val connectionState: StateFlow<String> = _connectionState.asStateFlow()
    
    // Scan filter state
    private val _scanFilter = MutableStateFlow<String>("")
    val scanFilter: StateFlow<String> = _scanFilter.asStateFlow()

    private val foundDevices = mutableMapOf<String, BleDevice>()

    // Scan callback
    private val scanCallback = object : ScanCallback() {
        override fun onScanResult(callbackType: Int, result: ScanResult) {
            if (!hasBlePermissions()) return
            
            val device = result.device
            val rssi = result.rssi
            val deviceName = device.name ?: "Unknown Device"
            
            // Apply name filter if set
            val currentFilter = _scanFilter.value
            if (currentFilter.isNotEmpty() && !deviceName.lowercase().contains(currentFilter.lowercase())) {
                return // Skip this device as it doesn't match the filter
            }
            
            val bleDevice = BleDevice.fromBluetoothDevice(
                device = device,
                rssi = rssi,
                isConnected = connectedDevices.contains(device),
                isPaired = device.bondState == BluetoothDevice.BOND_BONDED
            )
            
            foundDevices[device.address] = bleDevice
            
            // Apply filter to the entire list before updating UI
            val filteredDevices = if (currentFilter.isNotEmpty()) {
                foundDevices.values.filter { 
                    it.name.lowercase().contains(currentFilter.lowercase()) 
                }
            } else {
                foundDevices.values.toList()
            }
            
            _scannedDevices.value = filteredDevices.sortedByDescending { it.rssi }
            
            Log.d(TAG, "Found device: ${bleDevice.name} (${bleDevice.address}) RSSI: ${bleDevice.rssi}")
        }

        override fun onScanFailed(errorCode: Int) {
            Log.e(TAG, "Scan failed with error: $errorCode")
            _isScanning.value = false
        }
    }

    // GATT client callback
    private val gattClientCallback = object : BluetoothGattCallback() {
        override fun onConnectionStateChange(gatt: BluetoothGatt, status: Int, newState: Int) {
            if (!hasBlePermissions()) return
            
            when (newState) {
                BluetoothProfile.STATE_CONNECTED -> {
                    Log.d(TAG, "âœ… Connected to GATT client (acting as central)")
                    connectedDevices.add(gatt.device)
                    _connectionState.value = "Connected to ${gatt.device.name ?: "Unknown"}"
                    
                    // Start bonding process
                    if (gatt.device.bondState != BluetoothDevice.BOND_BONDED) {
                        Log.d(TAG, "ðŸ¤ Starting bonding process...")
                        gatt.device.createBond()
                    }
                    
                    // GATT server should already be running (started before connection)
                    Log.d(TAG, "ðŸ” GATT Server status: ${if (gattServer != null) "Running" else "Not Running"}")
                    Log.d(TAG, "ðŸ“Š Available services: ${gattServer?.services?.size ?: 0}")
                    
                    // Discover services on the connected peripheral
                    Log.d(TAG, "ðŸ” Discovering services on peripheral...")
                    gatt.discoverServices()
                }
                BluetoothProfile.STATE_DISCONNECTED -> {
                    Log.d(TAG, "Disconnected from GATT server")
                    connectedDevices.remove(gatt.device)
                    _connectionState.value = "Disconnected"
                    gatt.close()
                }
            }
            updateDeviceConnectionStates()
        }

        override fun onServicesDiscovered(gatt: BluetoothGatt, status: Int) {
            if (status == BluetoothGatt.GATT_SUCCESS) {
                Log.d(TAG, "Services discovered successfully")
                // Handle discovered services if needed
            }
        }
        
        override fun onDescriptorWrite(gatt: BluetoothGatt, descriptor: BluetoothGattDescriptor, status: Int) {
            if (status == BluetoothGatt.GATT_SUCCESS) {
                Log.d(TAG, "Descriptor write successful: ${descriptor.uuid}")
            } else {
                Log.e(TAG, "Descriptor write failed with status: $status")
            }
        }
        
        override fun onCharacteristicWrite(gatt: BluetoothGatt, characteristic: BluetoothGattCharacteristic, status: Int) {
            if (status == BluetoothGatt.GATT_SUCCESS) {
                Log.d(TAG, "Characteristic write successful: ${characteristic.uuid}")
            } else {
                Log.e(TAG, "Characteristic write failed with status: $status")
            }
        }
        
        override fun onCharacteristicChanged(gatt: BluetoothGatt, characteristic: BluetoothGattCharacteristic) {
            Log.d(TAG, "Characteristic changed: ${characteristic.uuid}")
            // Handle characteristic notifications from peripheral
            val data = characteristic.value
            if (data != null) {
                Log.d(TAG, "Received data from ${characteristic.uuid}: ${data.contentToString()}")
            }
        }
    }

    fun cleanup() {
        stopScan()
        disconnectFromDevice()
        deviceSubscriptions.clear()
    }
}